/**
 * Nanobanana2 Image Generation Integration (Type 1: External System Integration)
 *
 * Purpose: Integrate with Nanobanana2 AI image generation service for generating images
 * from prompts and reference images. Uses Temporal workflows for async processing.
 *
 * Architecture (Task 6 - Unified Temporal Approach):
 * - Integration only communicates with Temporal workflow
 * - ALL external API calls (generate image, upload) are in Temporal activities
 * - Workflow reports status back via callback API
 *
 * Flow:
 * 1. On APICall creation: Start Temporal workflow with request params
 * 2. Workflow: Report 'processing' -> Generate image -> Upload -> Report result
 * 3. Manual query: Returns current known status from APICall entity
 *
 * This clean separation ensures:
 * - External API calls are durable and retriable (handled by Temporal)
 * - Integration layer is simple (only workflow orchestration)
 * - Status updates are reliable (callback mechanism)
 */

import { Controller, RecordMutationSideEffect, MatchExp } from 'interaqt'
import { IIntegration, IIntegrationConstructorArgs, API, buildAPIPath, PullModeConfig } from '@/integrations/index'
import { Client, Connection } from '@temporalio/client'
import {
  QueryStatusRequestSchema,
  QueryStatusResponseSchema,
  ReportResultRequestSchema,
  ReportResultResponseSchema,
  type QueryStatusRequest,
  type ReportResultRequest
} from './schemas'

// ============================================
// API Names - defined here and exported for use by activities
// ============================================

/**
 * API name for fetching pending tasks (Pull Mode)
 */
export const FETCH_PENDING_TASKS_API_NAME = 'fetchPendingTasks'

/**
 * API name for querying task status
 * This is a constant defined by the integration itself (not from config)
 */
export const QUERY_STATUS_API_NAME = 'queryNanobanana2Status'

/**
 * API name for reporting task results from Temporal workflow
 * This is a constant defined by the integration itself (not from config)
 */
export const REPORT_RESULT_API_NAME = 'reportNanobanana2Result'

/**
 * Side effect return type
 */
type Nanobanana2SideEffectResult = {
  success: boolean
  data?: {
    apiCallId: string
    workflowId: string
    status: 'queued' | 'processing' | 'completed' | 'failed'
    imageUrls?: string[]
  }
  error?: {
    message: string
    stack?: string
  }
  context?: {
    eventType?: string
    apiCallId?: string
  }
}

/**
 * Configuration interface for Nanobanana2 Image Generation
 */
export type Nanobanana2ImageGenerationConfig = {
  apiCallEntity: {
    entityName: string
    fields: {
      status: string
      externalId: string
      requestParams: string
      responseData: string
      createdAt: string
      startedAt: string  // Set when pending->queued (for stuck task detection)
      completedAt: string
      attempts: string   // Retry counter
      error: string
    }
  }

  eventEntity: {
    entityName: string
    fields: {
      eventType: string
      entityId: string
      externalId: string
      status: string
      createdAt: string
      data: string
    }
  }

  external: {
    apiKey: string
    baseUrl: string
    model: string
  }

  storage: {
    accessKeyId: string
    secretAccessKey: string
    region: string
    endpoint: string
    publicEndpoint: string // 用于生成公开访问的下载 URL
    bucket: string
    objectKeyPrefix: string
  }

  temporal: {
    address: string
    namespace: string
  }

  // Main component endpoint for callback URL
  mainEndpoint: string
}

// Task queue name for nanobanana2ImageGeneration workflows
// IMPORTANT: This MUST match the name generated by workflow-collector.ts
const TASK_QUEUE = 'integration-nanobanana2imagegeneration-queue'

/**
 * Create Nanobanana2 Image Generation Integration
 */
export function createNanobanana2ImageGenerationIntegration(config: Nanobanana2ImageGenerationConfig) {
  return class Nanobanana2ImageGenerationIntegration implements IIntegration {
    private storage: any
    private logger: any
    private controller?: Controller
    private temporalClient?: Client
    private temporalConnection?: Connection
    public readonly namespace: string

    constructor(public args: IIntegrationConstructorArgs) {
      this.namespace = args.namespace
    }

    async configure() {
      console.log('[Nanobanana2ImageGeneration] Integration configure phase - no action needed')
    }

    async setup(controller: Controller) {
      this.controller = controller
      this.storage = controller.system.storage
      this.logger = controller.system.logger

      // Initialize Temporal client
      try {
        this.temporalConnection = await Connection.connect({
          address: config.temporal.address
        })

        this.temporalClient = new Client({
          connection: this.temporalConnection,
          namespace: config.temporal.namespace
        })

        console.log('[Nanobanana2ImageGeneration] Temporal client connected', {
          address: config.temporal.address,
          namespace: config.temporal.namespace
        })
      } catch (error: any) {
        console.error('[Nanobanana2ImageGeneration] Failed to connect to Temporal', {
          address: config.temporal.address,
          error: error.message
        })
        // Don't throw - let the integration start, but workflow submission will fail
      }

      console.log('[Nanobanana2ImageGeneration] Integration setup completed')
    }

    /**
     * Returns Pull Mode configuration for TaskProcessor
     * 
     * Pull Mode allows TaskProcessor to fetch pending tasks via HTTP
     * and start workflows with idempotent IDs.
     */
    getPullModeConfig(): PullModeConfig {
      // Prepare storage config with proper endpoint
      const storageEndpoint =
        config.storage.endpoint.startsWith('http://') || config.storage.endpoint.startsWith('https://')
          ? config.storage.endpoint
          : `http://${config.storage.endpoint}`

      return {
        enabled: true,
        taskQueue: TASK_QUEUE,
        workflowName: 'imageGenerationWorkflow',
        buildWorkflowId: (apiCall) => `nanobanana2-${apiCall.id}`,
        buildWorkflowParams: (apiCall) => ({
          workflowId: `nanobanana2-${apiCall.id}`,
          apiCallId: apiCall.id,
          callbackUrl: `${config.mainEndpoint}/${buildAPIPath(this.namespace, REPORT_RESULT_API_NAME)}`,
          prompt: apiCall[config.apiCallEntity.fields.requestParams]?.prompt,
          referenceImageUrl: apiCall[config.apiCallEntity.fields.requestParams]?.referenceImageUrl,
          apiKey: config.external.apiKey,
          baseUrl: config.external.baseUrl,
          model: config.external.model,
          storage: {
            accessKeyId: config.storage.accessKeyId,
            secretAccessKey: config.storage.secretAccessKey,
            region: config.storage.region,
            endpoint: storageEndpoint,
            publicEndpoint: config.storage.publicEndpoint,
            bucket: config.storage.bucket,
            forcePathStyle: true
          },
          objectKeyPrefix: config.storage.objectKeyPrefix
        }),
        internalAPIs: {
          fetchPendingTasks: `${config.mainEndpoint}/${buildAPIPath(this.namespace, FETCH_PENDING_TASKS_API_NAME)}`,
          reportTaskEvent: `${config.mainEndpoint}/${buildAPIPath(this.namespace, REPORT_RESULT_API_NAME)}`
        }
      }
    }

    /**
     * Side Effects are disabled in Pull Mode
     * TaskProcessor handles task dispatching instead
     */
    createSideEffects(): RecordMutationSideEffect<Nanobanana2SideEffectResult>[] {
      // Pull Mode: No side effects - TaskProcessor polls for pending tasks
      console.log('[Nanobanana2ImageGeneration] Pull Mode enabled - Side Effects disabled')
      return []
    }

    createAPIs(): API[] {
      const self = this
      
      // Constants for fetchPendingTasks API
      const MAX_ATTEMPTS = 5
      const STUCK_TIMEOUT_SECONDS = 300  // 5 minutes

      return [
        // ============================================
        // Internal API: fetchPendingTasks (for Pull Mode)
        // Called by TaskProcessor to get tasks that need processing
        // Note: allowAnonymous=true because this is an internal API
        // In production, network policies should restrict access
        // ============================================
        {
          name: FETCH_PENDING_TASKS_API_NAME,
          namespace: this.namespace,
          allowAnonymous: true,  // Internal API - secured by network policy in production
          useNamedParams: true,
          callback: async function(this: Controller, context, params: { limit?: number }) {
            const nowSeconds = Math.floor(Date.now() / 1000)
            const limit = params?.limit || 10

            // Condition 1: pending status tasks
            const pendingCondition = MatchExp.atom({
              key: config.apiCallEntity.fields.status,
              value: ['=', 'pending']
            })

            // Condition 2: failed tasks with attempts < maxAttempts (eligible for retry)
            const failedCondition = MatchExp.atom({
              key: config.apiCallEntity.fields.status,
              value: ['=', 'failed']
            }).and({
              key: config.apiCallEntity.fields.attempts,
              value: ['<', MAX_ATTEMPTS]
            })

            // Condition 3: stuck tasks (queued but timed out, with attempts < maxAttempts)
            const stuckCondition = MatchExp.atom({
              key: config.apiCallEntity.fields.status,
              value: ['=', 'queued']
            }).and({
              key: config.apiCallEntity.fields.startedAt,
              value: ['<', nowSeconds - STUCK_TIMEOUT_SECONDS]
            }).and({
              key: config.apiCallEntity.fields.attempts,
              value: ['<', MAX_ATTEMPTS]
            })

            const match = pendingCondition.or(failedCondition).or(stuckCondition)

            const tasks = await this.system.storage.find(
              config.apiCallEntity.entityName,
              match,
              { limit, orderBy: { [config.apiCallEntity.fields.createdAt]: 'asc' } },
              [
                'id', 
                config.apiCallEntity.fields.status, 
                config.apiCallEntity.fields.startedAt,
                config.apiCallEntity.fields.attempts, 
                config.apiCallEntity.fields.requestParams,
                config.apiCallEntity.fields.createdAt
              ]
            )

            return { tasks: tasks || [] }
          }
        },
        
        {
          name: QUERY_STATUS_API_NAME,
          namespace: this.namespace,
          callback: async function (this: Controller, context, params: QueryStatusRequest) {
            try {
              console.log('[Nanobanana2ImageGeneration] Status query requested', {
                apiCallId: params.apiCallId
              })

              // Query APICall entity for current status
              const apiCall = await this.system.storage.findOne(
                config.apiCallEntity.entityName,
                MatchExp.atom({ key: 'id', value: ['=', params.apiCallId] }),
                undefined,
                ['id', config.apiCallEntity.fields.status, config.apiCallEntity.fields.externalId]
              )

              if (!apiCall) {
                return {
                  success: false,
                  error: `APICall not found: ${params.apiCallId}`
                }
              }

              const currentStatus = apiCall[config.apiCallEntity.fields.status]

              console.log('[Nanobanana2ImageGeneration] Current status', {
                apiCallId: params.apiCallId,
                currentStatus
              })

              return {
                success: true,
                message: `Current status: ${currentStatus || 'unknown'}`
              }
            } catch (error: any) {
              console.error('[Nanobanana2ImageGeneration] Failed to query status', {
                apiCallId: params.apiCallId,
                error: error.message
              })
              return {
                success: false,
                error: error.message
              }
            }
          },
          paramsSchema: QueryStatusRequestSchema,
          responseSchema: QueryStatusResponseSchema,
          useNamedParams: true,
          allowAnonymous: false,
          openapi: {
            summary: 'Query Nanobanana2 image generation status',
            description: 'Returns the current known status of the image generation task from APICall entity.',
            tags: ['ImageGeneration']
          }
        },

        /**
         * Result callback API - called by Temporal workflow to report task status
         * 
         * This API is called from the workflow's activity:
         * 1. After workflow is picked up by worker: status='queued' with apiCallId
         * 2. Before calling external API: status='processing' with apiCallId and externalId (for debugging)
         * 3. After task completion: status='completed' or 'failed' with apiCallId
         * 
         * Important: ALL events MUST have apiCallId (entityId) for state machine matching.
         */
        {
          name: REPORT_RESULT_API_NAME,
          namespace: this.namespace,
          callback: async function (this: Controller, context, params: ReportResultRequest) {
            try {
              console.log('[Nanobanana2ImageGeneration] Result callback received', {
                workflowId: params.workflowId,
                status: params.status,
                hasApiCallId: !!params.apiCallId,
                hasImageUrls: !!params.imageUrls,
                hasError: !!params.error
              })

              // All events require apiCallId for state machine matching
              if (!params.apiCallId) {
                console.error('[Nanobanana2ImageGeneration] Missing apiCallId for status', {
                  status: params.status
                })
                return {
                  success: false,
                  error: 'apiCallId is required for all events'
                }
              }

              // For 'queued' status, perform double-check before creating event
              // This ensures concurrent TaskProcessors don't create duplicate events
              if (params.status === 'queued') {
                // Double-check: verify current status allows transition to queued
                const currentTask = await this.system.storage.findOne(
                  config.apiCallEntity.entityName,
                  MatchExp.atom({ key: 'id', value: ['=', params.apiCallId] }),
                  undefined,
                  ['id', config.apiCallEntity.fields.status]
                )

                if (!currentTask) {
                  return { success: false, error: 'Task not found' }
                }

                const currentStatus = currentTask[config.apiCallEntity.fields.status]
                
                // Only allow transition from pending or failed to queued
                if (currentStatus !== 'pending' && currentStatus !== 'failed') {
                  console.log('[Nanobanana2ImageGeneration] Task already processed, skipping queued event', {
                    apiCallId: params.apiCallId,
                    currentStatus
                  })
                  return { 
                    success: false, 
                    error: `Cannot transition to queued from ${currentStatus}` 
                  }
                }

                // Create queued event - only entityId needed
                await self.createIntegrationEvent(
                  this,
                  params.apiCallId,
                  null, // No externalId for queued
                  'queued',
                  null,
                  null
                )

                console.log('[Nanobanana2ImageGeneration] Queued event created', {
                  workflowId: params.workflowId,
                  apiCallId: params.apiCallId
                })

                return {
                  success: true,
                  message: 'Queued event created'
                }
              }

              // For 'processing' status, include externalId for debugging
              if (params.status === 'processing') {
                // Create processing event with entityId and externalId (for debugging)
                // For sync APIs, externalId is the apiCallId itself
                await self.createIntegrationEvent(
                  this,
                  params.apiCallId,
                  params.externalId || params.apiCallId, // Use apiCallId as externalId for sync APIs
                  'processing',
                  null,
                  null
                )

                console.log('[Nanobanana2ImageGeneration] Processing event created', {
                  workflowId: params.workflowId,
                  apiCallId: params.apiCallId,
                  externalId: params.externalId || params.apiCallId
                })

                return {
                  success: true,
                  message: 'Processing event created'
                }
              }

              // For terminal status, check if APICall is already in terminal state
              const apiCall = await this.system.storage.findOne(
                config.apiCallEntity.entityName,
                MatchExp.atom({ key: 'id', value: ['=', params.apiCallId] }),
                undefined,
                ['id', config.apiCallEntity.fields.status]
              )

              if (apiCall) {
                const currentStatus = apiCall[config.apiCallEntity.fields.status]
                if (currentStatus === 'completed' || currentStatus === 'failed') {
                  console.log('[Nanobanana2ImageGeneration] APICall already terminal, skipping', {
                    apiCallId: params.apiCallId,
                    currentStatus
                  })
                  return {
                    success: true,
                    message: `APICall already ${currentStatus}, no event created`
                  }
                }
              }

              // Prepare event data
              let eventData: any = null
              let errorMessage: string | null = null

              if (params.status === 'completed' && params.imageUrls) {
                eventData = {
                  imageUrls: params.imageUrls
                }
              } else if (params.status === 'failed' && params.error) {
                errorMessage = params.error
              }

              // Create terminal integration event with entityId
              await self.createIntegrationEvent(
                this,
                params.apiCallId,
                null, // externalId not needed for terminal events
                params.status,
                eventData,
                errorMessage
              )

              console.log('[Nanobanana2ImageGeneration] Terminal event created via callback', {
                apiCallId: params.apiCallId,
                status: params.status
              })

              return {
                success: true,
                message: `Integration event created with status: ${params.status}`
              }
            } catch (error: any) {
              console.error('[Nanobanana2ImageGeneration] Failed to process result callback', {
                apiCallId: params.apiCallId,
                error: error.message
              })
              return {
                success: false,
                error: error.message
              }
            }
          },
          paramsSchema: ReportResultRequestSchema,
          responseSchema: ReportResultResponseSchema,
          useNamedParams: true,
          // Allow anonymous access since this is called from Temporal worker
          allowAnonymous: true,
          openapi: {
            summary: 'Report Nanobanana2 image generation result',
            description: 'Callback API for Temporal workflow to report task status. Creates integration event for queued/processing/completed/failed status.',
            tags: ['ImageGeneration']
          }
        }
      ]
    }

    /**
     * Create integration event to trigger reactive updates
     */
    private async createIntegrationEvent(
      controller: Controller,
      entityId: string | null,
      externalId: string | null,
      status: string,
      data: any | null,
      errorMessage: string | null
    ) {
      try {
        const eventData: any = {
          [config.eventEntity.fields.eventType]: 'task.status.update',
          [config.eventEntity.fields.status]: status,
          [config.eventEntity.fields.createdAt]: Math.floor(Date.now() / 1000)
        }

        // Add entityId (APICall id) - required for first event only
        if (entityId) {
          eventData[config.eventEntity.fields.entityId] = entityId
        }

        // Add externalId - workflow ID
        if (externalId) {
          eventData[config.eventEntity.fields.externalId] = externalId
        }

        // Add event payload data
        if (data) {
          eventData[config.eventEntity.fields.data] = data
        }

        // Add error message to data field if failed
        if (errorMessage) {
          eventData[config.eventEntity.fields.data] = {
            ...eventData[config.eventEntity.fields.data],
            errorMessage,
            errorCode: 'workflow_error'
          }
        }

        await controller.system.storage.create(config.eventEntity.entityName, eventData)

        console.log('[Nanobanana2ImageGeneration] Integration event created', {
          entityId,
          externalId,
          status,
          hasData: !!data,
          hasError: !!errorMessage
        })
      } catch (error: any) {
        console.error('[Nanobanana2ImageGeneration] Failed to create integration event', {
          entityId,
          externalId,
          status,
          error: error.message
        })
      }
    }
  }
}
