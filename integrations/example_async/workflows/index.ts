/**
 * Fangzhou Video Generation Workflows
 *
 * Temporal Workflows for video generation task creation and polling
 *
 * Workflow features:
 * 1. Durable - workflow can resume from checkpoint after process restart
 * 2. Retriable - activities are automatically retried on failure
 * 3. Queryable - workflow status can be queried at any time
 * 4. Signalable - can receive signals to stop polling early (manual query found result)
 *
 * Unified Flow (All external API calls are in activities):
 * 1. Receive request params from integration
 * 2. Call createVideoTask activity to create task via external API
 * 3. Report 'processing' status back to main component
 * 4. Poll for status until terminal state or signal received
 * 5. Report final status back to main component
 */

import { proxyActivities, defineSignal, setHandler, condition } from '@temporalio/workflow'
import type * as activities from '../activities/index.js'

// Proxy activities - allows calling them from workflow
// Separate configs for different activity types
const { createVideoTask } = proxyActivities<typeof activities>({
  startToCloseTimeout: '5 minutes', // Task creation may involve image fetching
  retry: {
    maximumAttempts: 3,
    initialInterval: '5 seconds',
    maximumInterval: '30 seconds',
    backoffCoefficient: 2
  }
})

const { pollVideoStatus, reportToMain } = proxyActivities<typeof activities>({
  startToCloseTimeout: '2 minutes', // Each poll attempt timeout
  retry: {
    maximumAttempts: 3,
    initialInterval: '5 seconds',
    maximumInterval: '30 seconds',
    backoffCoefficient: 2
  }
})

/**
 * Signal to stop polling (when manual query finds result)
 */
export const stopPollingSignal = defineSignal<[{ reason: string; status?: string }]>('stopPolling')

/**
 * Signal to trigger immediate poll (manual query requests immediate check)
 */
export const triggerImmediatePollSignal = defineSignal<[{ reason: string }]>('triggerImmediatePoll')

/**
 * Video Generation Workflow Parameters
 *
 * Changed in Task 5: Now receives requestParams instead of taskId
 * The workflow creates the external task itself via createVideoTask activity
 */
export type VideoPollingWorkflowParams = {
  // Workflow identification (generated by integration before task creation)
  workflowId: string
  // APICall entity ID (for reference in events)
  apiCallId: string
  // Request parameters from APICall entity
  requestParams: {
    firstFrameImageUrl?: string
    prompt?: string
    frames?: number
  }
  // Callback URL for reporting result to main component
  callbackUrl: string
  // API config
  apiKey: string
  baseUrl: string
  model: string
  // Polling config
  pollingIntervalSeconds?: number // Default: 10 seconds
  maxPollingDurationSeconds?: number // Default: 30 minutes (1800 seconds)
}

/**
 * Video Generation Workflow Result
 */
export type VideoPollingWorkflowResult = {
  success: boolean
  status: 'completed' | 'failed' | 'cancelled'
  taskId?: string // External task ID (from Fangzhou)
  videoUrl?: string
  error?: string
  completedAt: number
  stoppedBySignal?: boolean
}

/**
 * Video Generation Workflow
 *
 * This workflow handles the complete video generation lifecycle:
 * 1. Report 'queued' status to main component (worker picked up task, only entityId needed)
 * 2. Create task via external API (using createVideoTask activity)
 * 3. Report 'processing' status when external API task created successfully (with externalId)
 * 4. Poll for status until terminal state
 * 5. Report final status to main component
 *
 * All external API calls are now inside activities, making the integration
 * layer cleaner (it only communicates with Temporal).
 */
export async function videoPollingWorkflow(
  params: VideoPollingWorkflowParams
): Promise<VideoPollingWorkflowResult> {
  console.log('[Workflow:videoPollingWorkflow] Starting', {
    workflowId: params.workflowId,
    apiCallId: params.apiCallId
  })

  const pollingIntervalSeconds = params.pollingIntervalSeconds || 10
  const maxPollingDurationSeconds = params.maxPollingDurationSeconds || 1800 // 30 minutes

  // Track if we received signals
  let stopSignalReceived = false
  let stopReason: string | undefined
  let signalStatus: string | undefined
  let triggerImmediatePollReceived = false

  // Register signal handlers
  setHandler(stopPollingSignal, (data) => {
    console.log('[Workflow:videoPollingWorkflow] Received stop signal', {
      workflowId: params.workflowId,
      reason: data.reason,
      status: data.status
    })
    stopSignalReceived = true
    stopReason = data.reason
    signalStatus = data.status
  })

  setHandler(triggerImmediatePollSignal, (data) => {
    console.log('[Workflow:videoPollingWorkflow] Received trigger immediate poll signal', {
      workflowId: params.workflowId,
      reason: data.reason
    })
    triggerImmediatePollReceived = true
  })

  // ============================================
  // NOTE: 'queued' status is reported by TaskProcessor BEFORE starting workflow
  // This is the Pull Mode architecture - TaskProcessor owns the queued transition
  // ============================================

  // ============================================
  // Step 1: Create video generation task via external API
  // ============================================
  console.log('[Workflow:videoPollingWorkflow] Creating video task', {
    workflowId: params.workflowId,
    apiCallId: params.apiCallId
  })

  const createResult = await createVideoTask({
    requestParams: params.requestParams,
    apiKey: params.apiKey,
    baseUrl: params.baseUrl,
    model: params.model
  })

  if (!createResult.success || !createResult.taskId) {
    console.error('[Workflow:videoPollingWorkflow] Failed to create task', {
      workflowId: params.workflowId,
      error: createResult.error
    })

    // Report failure to main component (queued -> failed)
    await reportToMain({
      callbackUrl: params.callbackUrl,
      status: 'failed',
      apiCallId: params.apiCallId
      // No taskId - failed before external API call
    })

    return {
      success: false,
      status: 'failed',
      error: createResult.error || 'Failed to create video generation task',
      completedAt: Date.now()
    }
  }

  const taskId = createResult.taskId

  console.log('[Workflow:videoPollingWorkflow] Task created successfully', {
    workflowId: params.workflowId,
    taskId
  })

  // ============================================
  // Step 2: Report 'processing' status (external task created, now have externalId)
  // ============================================
  await reportToMain({
    callbackUrl: params.callbackUrl,
    status: 'processing',
    apiCallId: params.apiCallId, // entityId for state machine matching
    taskId // externalId from external API for debugging
  })

  console.log('[Workflow:videoPollingWorkflow] Reported processing status', {
    workflowId: params.workflowId,
    apiCallId: params.apiCallId,
    taskId
  })

  // ============================================
  // Step 3: Poll for status until terminal state
  // ============================================
  const startTime = Date.now()
  const maxDurationMs = maxPollingDurationSeconds * 1000

  try {
    while (true) {
      // Check if we exceeded max polling duration
      if (Date.now() - startTime > maxDurationMs) {
        console.log('[Workflow:videoPollingWorkflow] Max polling duration exceeded', {
          workflowId: params.workflowId,
          taskId
        })

        // Report timeout failure
        await reportToMain({
          callbackUrl: params.callbackUrl,
          status: 'failed',
          apiCallId: params.apiCallId,
          error: `Polling timeout after ${maxPollingDurationSeconds} seconds`
        })

        return {
          success: false,
          status: 'failed',
          taskId,
          error: `Polling timeout after ${maxPollingDurationSeconds} seconds`,
          completedAt: Date.now()
        }
      }

      // Check if stop signal received
      if (stopSignalReceived) {
        console.log('[Workflow:videoPollingWorkflow] Stopping due to signal', {
          workflowId: params.workflowId,
          reason: stopReason
        })

        // If signal includes status info (manual query found result), we don't need to report again
        // The manual query API already created the integration event
        return {
          success: true,
          status: (signalStatus as 'completed' | 'failed') || 'completed',
          taskId,
          completedAt: Date.now(),
          stoppedBySignal: true
        }
      }

      // Poll external API for status
      console.log('[Workflow:videoPollingWorkflow] Polling status', {
        workflowId: params.workflowId,
        taskId
      })

      const pollResult = await pollVideoStatus({
        taskId,
        apiKey: params.apiKey,
        baseUrl: params.baseUrl,
        model: params.model
      })

      console.log('[Workflow:videoPollingWorkflow] Poll result', {
        workflowId: params.workflowId,
        status: pollResult.status,
        hasVideoUrl: !!pollResult.videoUrl
      })

      // Check if status is terminal
      if (pollResult.status === 'succeeded') {
        console.log('[Workflow:videoPollingWorkflow] Task succeeded', {
          workflowId: params.workflowId,
          videoUrl: pollResult.videoUrl
        })

        // Report success result
        await reportToMain({
          callbackUrl: params.callbackUrl,
          status: 'completed',
          apiCallId: params.apiCallId,
          videoUrl: pollResult.videoUrl
        })

        return {
          success: true,
          status: 'completed',
          taskId,
          videoUrl: pollResult.videoUrl,
          completedAt: Date.now()
        }
      }

      if (pollResult.status === 'failed' || pollResult.status === 'cancelled') {
        console.log('[Workflow:videoPollingWorkflow] Task failed', {
          workflowId: params.workflowId,
          error: pollResult.error
        })

        // Report failure result
        await reportToMain({
          callbackUrl: params.callbackUrl,
          status: 'failed',
          apiCallId: params.apiCallId,
          error: pollResult.error
        })

        return {
          success: false,
          status: 'failed',
          taskId,
          error: pollResult.error,
          completedAt: Date.now()
        }
      }

      // Status is still processing, wait for next poll interval
      // Use condition with timeout to allow signals to interrupt the sleep
      // Either stopPolling or triggerImmediatePoll will break the wait
      await condition(() => stopSignalReceived || triggerImmediatePollReceived, pollingIntervalSeconds * 1000)
      
      // Reset immediate poll flag for next iteration
      triggerImmediatePollReceived = false
    }
  } catch (error: any) {
    console.error('[Workflow:videoPollingWorkflow] Workflow failed', {
      workflowId: params.workflowId,
      error: error.message
    })

    // Report failure result
    await reportToMain({
      callbackUrl: params.callbackUrl,
      status: 'failed',
      apiCallId: params.apiCallId,
      error: error.message
    })

    return {
      success: false,
      status: 'failed',
      taskId,
      error: error.message,
      completedAt: Date.now()
    }
  }
}
