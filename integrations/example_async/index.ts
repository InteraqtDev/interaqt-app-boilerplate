/**
 * Fangzhou Video Generation Integration (Type 1: External System Integration)
 *
 * Purpose: Integrate with Volcengine Fangzhou Seedance API for AI video generation
 * Uses Temporal workflows for all external API interactions.
 *
 * Architecture (Task 5 - Unified Temporal Approach):
 * - Integration only communicates with Temporal workflow
 * - ALL external API calls (create task, poll status) are in Temporal activities
 * - Workflow reports status back via callback API
 *
 * Flow:
 * 1. On APICall creation: Start Temporal workflow with request params
 * 2. Workflow: Create task via activity -> Report 'processing' -> Poll status -> Report result
 * 3. Manual query: Triggers immediate poll via signal, returns current known status
 *
 * This clean separation ensures:
 * - External API calls are durable and retriable (handled by Temporal)
 * - Integration layer is simple (only workflow orchestration)
 * - Status updates are reliable (callback mechanism)
 */

import { Controller, RecordMutationSideEffect, MatchExp } from 'interaqt'
import { IIntegration, IIntegrationConstructorArgs, API, buildAPIPath, PullModeConfig } from '@/integrations/index'
import { Client, Connection } from '@temporalio/client'
import {
  QueryStatusRequestSchema,
  QueryStatusResponseSchema,
  ReportResultRequestSchema,
  ReportResultResponseSchema,
  type QueryStatusRequest,
  type ReportResultRequest
} from './schemas'

// ============================================
// API Names - defined here as constants
// ============================================

/**
 * API name for fetching pending tasks (Pull Mode)
 */
export const FETCH_PENDING_TASKS_API_NAME = 'fetchPendingTasks'

/**
 * API name for querying video generation status
 */
export const QUERY_STATUS_API_NAME = 'queryFangzhouVideoStatus'

/**
 * API name for reporting task results from Temporal workflow
 */
export const REPORT_RESULT_API_NAME = 'reportFangzhouVideoResult'

/**
 * Side effect return type
 */
type FangzhouVideoSideEffectResult = {
  success: boolean
  data?: {
    apiCallId: string
    taskId?: string
    workflowId?: string
    status?: 'queued' | 'processing' | 'completed' | 'failed'
  }
  error?: {
    message: string
    stack?: string
  }
  context?: {
    eventType?: string
    apiCallId?: string
  }
}

/**
 * Configuration interface for Fangzhou Video Generation
 */
export type FangzhouVideoGenerationConfig = {
  apiCallEntity: {
    entityName: string
    fields: {
      status: string
      externalId: string
      requestParams: string
      responseData: string
      createdAt: string
      startedAt: string  // Set when pending->queued (for stuck task detection)
      completedAt: string
      attempts: string   // Retry counter
      error: string
    }
  }

  eventEntity: {
    entityName: string
    fields: {
      eventType: string
      entityId: string
      externalId: string
      status: string
      createdAt: string
      data: string
    }
  }

  external: {
    apiKey: string
    baseUrl: string
    model: string
  }

  temporal: {
    address: string
    namespace: string
  }

  // Main component endpoint for callback URL
  mainEndpoint: string

  // Polling config (optional)
  polling?: {
    intervalSeconds?: number // Default: 10 seconds
    maxDurationSeconds?: number // Default: 1800 seconds (30 minutes)
  }
}

// Task queue name for fangzhouVideoGeneration workflows
// IMPORTANT: This MUST match the name generated by workflow-collector.ts
const TASK_QUEUE = 'integration-fangzhouvideogeneration-queue'

/**
 * Create Fangzhou Video Generation Integration
 */
export function createFangzhouVideoGenerationIntegration(config: FangzhouVideoGenerationConfig) {
  return class FangzhouVideoGenerationIntegration implements IIntegration {
    private storage: any
    private logger: any
    private controller?: Controller
    private temporalClient?: Client
    private temporalConnection?: Connection
    public readonly namespace: string

    constructor(public args: IIntegrationConstructorArgs) {
      this.namespace = args.namespace
    }

    async configure() {
      console.log('[FangzhouVideoGeneration] Integration configure phase - no action needed')
    }

    async setup(controller: Controller) {
      this.controller = controller
      this.storage = controller.system.storage
      this.logger = controller.system.logger

      // Initialize Temporal client
      try {
        this.temporalConnection = await Connection.connect({
          address: config.temporal.address
        })

        this.temporalClient = new Client({
          connection: this.temporalConnection,
          namespace: config.temporal.namespace
        })

        console.log('[FangzhouVideoGeneration] Temporal client connected', {
          address: config.temporal.address,
          namespace: config.temporal.namespace
        })
      } catch (error: any) {
        console.error('[FangzhouVideoGeneration] Failed to connect to Temporal', {
          address: config.temporal.address,
          error: error.message
        })
        // Don't throw - let the integration start, but workflow submission will fail
      }

      console.log('[FangzhouVideoGeneration] Integration setup completed')
    }

    /**
     * Returns Pull Mode configuration for TaskProcessor
     * 
     * Pull Mode allows TaskProcessor to fetch pending tasks via HTTP
     * and start workflows with idempotent IDs.
     */
    getPullModeConfig(): PullModeConfig {
      return {
        enabled: true,
        taskQueue: TASK_QUEUE,
        workflowName: 'videoPollingWorkflow',
        buildWorkflowId: (apiCall) => `fangzhou-video-apicall-${apiCall.id}`,
        buildWorkflowParams: (apiCall) => ({
          workflowId: `fangzhou-video-apicall-${apiCall.id}`,
          apiCallId: apiCall.id,
          requestParams: {
            firstFrameImageUrl: apiCall[config.apiCallEntity.fields.requestParams]?.firstFrameImageUrl,
            prompt: apiCall[config.apiCallEntity.fields.requestParams]?.prompt,
            frames: apiCall[config.apiCallEntity.fields.requestParams]?.frames
          },
          callbackUrl: `${config.mainEndpoint}/${buildAPIPath(this.namespace, REPORT_RESULT_API_NAME)}`,
          apiKey: config.external.apiKey,
          baseUrl: config.external.baseUrl,
          model: config.external.model,
          pollingIntervalSeconds: config.polling?.intervalSeconds || 10,
          maxPollingDurationSeconds: config.polling?.maxDurationSeconds || 1800
        }),
        internalAPIs: {
          fetchPendingTasks: `${config.mainEndpoint}/${buildAPIPath(this.namespace, FETCH_PENDING_TASKS_API_NAME)}`,
          reportTaskEvent: `${config.mainEndpoint}/${buildAPIPath(this.namespace, REPORT_RESULT_API_NAME)}`
        }
      }
    }

    /**
     * Side Effects are disabled in Pull Mode
     * TaskProcessor handles task dispatching instead
     */
    createSideEffects(): RecordMutationSideEffect<FangzhouVideoSideEffectResult>[] {
      // Pull Mode: No side effects - TaskProcessor polls for pending tasks
      console.log('[FangzhouVideoGeneration] Pull Mode enabled - Side Effects disabled')
      return []
    }

    createAPIs(): API[] {
      const self = this
      // Constants for fetchPendingTasks API
      const MAX_ATTEMPTS = 5
      const STUCK_TIMEOUT_SECONDS = 300  // 5 minutes

      return [
        // ============================================
        // Internal API: fetchPendingTasks (for Pull Mode)
        // Called by TaskProcessor to get tasks that need processing
        // Note: allowAnonymous=true because this is an internal API
        // In production, network policies should restrict access
        // ============================================
        {
          name: FETCH_PENDING_TASKS_API_NAME,
          namespace: this.namespace,
          allowAnonymous: true,  // Internal API - secured by network policy in production
          useNamedParams: true,
          callback: async function(this: Controller, context, params: { limit?: number }) {
            const nowSeconds = Math.floor(Date.now() / 1000)
            const limit = params?.limit || 10

            // Condition 1: pending status tasks
            const pendingCondition = MatchExp.atom({
              key: config.apiCallEntity.fields.status,
              value: ['=', 'pending']
            })

            // Condition 2: failed tasks with attempts < maxAttempts (eligible for retry)
            const failedCondition = MatchExp.atom({
              key: config.apiCallEntity.fields.status,
              value: ['=', 'failed']
            }).and({
              key: config.apiCallEntity.fields.attempts,
              value: ['<', MAX_ATTEMPTS]
            })

            // Condition 3: stuck tasks (queued but timed out, with attempts < maxAttempts)
            const stuckCondition = MatchExp.atom({
              key: config.apiCallEntity.fields.status,
              value: ['=', 'queued']
            }).and({
              key: config.apiCallEntity.fields.startedAt,
              value: ['<', nowSeconds - STUCK_TIMEOUT_SECONDS]
            }).and({
              key: config.apiCallEntity.fields.attempts,
              value: ['<', MAX_ATTEMPTS]
            })

            const match = pendingCondition.or(failedCondition).or(stuckCondition)

            const tasks = await this.system.storage.find(
              config.apiCallEntity.entityName,
              match,
              { limit, orderBy: { [config.apiCallEntity.fields.createdAt]: 'asc' } },
              [
                'id', 
                config.apiCallEntity.fields.status, 
                config.apiCallEntity.fields.startedAt,
                config.apiCallEntity.fields.attempts, 
                config.apiCallEntity.fields.requestParams,
                config.apiCallEntity.fields.createdAt
              ]
            )

            return { tasks: tasks || [] }
          }
        },
        
        {
          name: QUERY_STATUS_API_NAME,
          namespace: this.namespace,
          callback: async function (this: Controller, context, params: QueryStatusRequest) {
            try {
              console.log('[FangzhouVideoGeneration] Manual status query requested', {
                apiCallId: params.apiCallId
              })

              // Query APICall entity for current status
              const apiCall = await this.system.storage.findOne(
                config.apiCallEntity.entityName,
                MatchExp.atom({ key: 'id', value: ['=', params.apiCallId] }),
                undefined,
                ['id', config.apiCallEntity.fields.status, config.apiCallEntity.fields.externalId]
              )

              if (!apiCall) {
                return {
                  success: false,
                  error: `APICall not found: ${params.apiCallId}`
                }
              }

              const currentStatus = apiCall[config.apiCallEntity.fields.status]
              const externalId = apiCall[config.apiCallEntity.fields.externalId]

              console.log('[FangzhouVideoGeneration] Current status', {
                apiCallId: params.apiCallId,
                externalId,
                currentStatus
              })

              // If already in terminal state, no need to trigger poll
              if (currentStatus === 'completed' || currentStatus === 'failed') {
                return {
                  success: true,
                  message: `Task already ${currentStatus}`
                }
              }

              // Send signal to workflow to trigger immediate poll
              if (self.temporalClient) {
                try {
                  const workflowId = `fangzhou-video-apicall-${params.apiCallId}`
                  const handle = self.temporalClient.workflow.getHandle(workflowId)
                  await handle.signal('triggerImmediatePoll', { reason: 'manual_query' })

                  console.log('[FangzhouVideoGeneration] Sent triggerImmediatePoll signal', {
                    apiCallId: params.apiCallId,
                    workflowId
                  })

                  return {
                    success: true,
                    message: `Triggered immediate status check. Current status: ${currentStatus || 'processing'}`
                  }
                } catch (signalError: any) {
                  // Workflow might have already completed or doesn't exist
                  console.log('[FangzhouVideoGeneration] Could not signal workflow', {
                    apiCallId: params.apiCallId,
                    error: signalError.message
                  })

                  return {
                    success: true,
                    message: `Current status: ${currentStatus || 'unknown'}. Workflow may have completed.`
                  }
                }
              }

              return {
                success: true,
                message: `Current status: ${currentStatus || 'unknown'}. Temporal client not available.`
              }
            } catch (error: any) {
              console.error('[FangzhouVideoGeneration] Failed to query status', {
                apiCallId: params.apiCallId,
                error: error.message
              })
              return {
                success: false,
                error: error.message
              }
            }
          },
          paramsSchema: QueryStatusRequestSchema,
          responseSchema: QueryStatusResponseSchema,
          useNamedParams: true,
          allowAnonymous: false,
          openapi: {
            summary: 'Query Fangzhou video generation status',
            description: 'Triggers immediate status check by signaling the Temporal workflow, and returns current known status.',
            tags: ['VideoGeneration']
          }
        },

        /**
         * Result callback API - called by Temporal workflow to report task status
         * 
         * This API is called from the workflow's activity:
         * 1. When workflow is picked up: status='queued' with apiCallId only
         * 2. After external API call: status='processing' with apiCallId AND taskId (externalId for debugging)
         * 3. After task completion: status='completed' or 'failed' with apiCallId
         * 
         * Important: ALL events MUST have apiCallId (entityId) for state machine matching.
         */
        {
          name: REPORT_RESULT_API_NAME,
          namespace: this.namespace,
          callback: async function (this: Controller, context, params: ReportResultRequest) {
            try {
              console.log('[FangzhouVideoGeneration] Result callback received', {
                apiCallId: params.apiCallId,
                taskId: params.taskId,
                status: params.status,
                hasVideoUrl: !!params.videoUrl,
                hasError: !!params.error
              })

              // All events require apiCallId for state machine matching
              if (!params.apiCallId) {
                console.error('[FangzhouVideoGeneration] Missing apiCallId for status', {
                  status: params.status
                })
                return {
                  success: false,
                  error: 'apiCallId is required for all events'
                }
              }

              // For 'queued' status, perform double-check before creating event
              // This ensures concurrent TaskProcessors don't create duplicate events
              if (params.status === 'queued') {
                // Double-check: verify current status allows transition to queued
                const currentTask = await this.system.storage.findOne(
                  config.apiCallEntity.entityName,
                  MatchExp.atom({ key: 'id', value: ['=', params.apiCallId] }),
                  undefined,
                  ['id', config.apiCallEntity.fields.status]
                )

                if (!currentTask) {
                  return { success: false, error: 'Task not found' }
                }

                const currentStatus = currentTask[config.apiCallEntity.fields.status]
                
                // Only allow transition from pending or failed to queued
                if (currentStatus !== 'pending' && currentStatus !== 'failed') {
                  console.log('[FangzhouVideoGeneration] Task already processed, skipping queued event', {
                    apiCallId: params.apiCallId,
                    currentStatus
                  })
                  return { 
                    success: false, 
                    error: `Cannot transition to queued from ${currentStatus}` 
                  }
                }

                // Create queued event - only entityId needed
                await self.createIntegrationEvent(
                  this,
                  params.apiCallId,
                  null, // No externalId yet
                  'queued',
                  null,
                  null
                )

                console.log('[FangzhouVideoGeneration] Queued event created', {
                  apiCallId: params.apiCallId
                })

                return {
                  success: true,
                  message: 'Queued event created'
                }
              }

              // For 'processing' status, include externalId (taskId) for debugging
              if (params.status === 'processing') {
                // Create processing event with both entityId and externalId
                await self.createIntegrationEvent(
                  this,
                  params.apiCallId, // entityId for state machine matching
                  params.taskId || null, // externalId from external API for debugging
                  'processing',
                  null,
                  null
                )

                console.log('[FangzhouVideoGeneration] Processing event created', {
                  apiCallId: params.apiCallId,
                  taskId: params.taskId
                })

                return {
                  success: true,
                  message: 'Processing event created'
                }
              }

              // For terminal status, check if APICall is already in terminal state
              const apiCall = await this.system.storage.findOne(
                config.apiCallEntity.entityName,
                MatchExp.atom({ key: 'id', value: ['=', params.apiCallId] }),
                undefined,
                ['id', config.apiCallEntity.fields.status]
              )

              if (apiCall) {
                const currentStatus = apiCall[config.apiCallEntity.fields.status]
                if (currentStatus === 'completed' || currentStatus === 'failed') {
                  console.log('[FangzhouVideoGeneration] APICall already terminal, skipping', {
                    apiCallId: params.apiCallId,
                    currentStatus
                  })
                  return {
                    success: true,
                    message: `APICall already ${currentStatus}, no event created`
                  }
                }
              }

              // Prepare event data
              let eventData: any = null
              let errorMessage: string | null = null

              if (params.status === 'completed' && params.videoUrl) {
                eventData = {
                  videoUrl: params.videoUrl
                }
              } else if (params.status === 'failed' && params.error) {
                errorMessage = params.error
              }

              // Create terminal integration event with entityId
              await self.createIntegrationEvent(
                this,
                params.apiCallId,
                null, // externalId not needed for terminal events
                params.status,
                eventData,
                errorMessage
              )

              console.log('[FangzhouVideoGeneration] Terminal event created via callback', {
                apiCallId: params.apiCallId,
                status: params.status
              })

              return {
                success: true,
                message: `Integration event created with status: ${params.status}`
              }
            } catch (error: any) {
              console.error('[FangzhouVideoGeneration] Failed to process result callback', {
                apiCallId: params.apiCallId,
                error: error.message
              })
              return {
                success: false,
                error: error.message
              }
            }
          },
          paramsSchema: ReportResultRequestSchema,
          responseSchema: ReportResultResponseSchema,
          useNamedParams: true,
          // Allow anonymous access since this is called from Temporal worker
          allowAnonymous: true,
          openapi: {
            summary: 'Report Fangzhou video generation result',
            description: 'Callback API for Temporal workflow to report task status. Creates integration event for queued/processing/completed/failed status.',
            tags: ['VideoGeneration']
          }
        }
      ]
    }

    /**
     * Create integration event to trigger reactive updates
     */
    private async createIntegrationEvent(
      controller: Controller,
      entityId: string | null,
      externalId: string | null,
      status: string,
      data: any | null,
      errorMessage: string | null
    ) {
      try {
        const eventData: any = {
          [config.eventEntity.fields.eventType]: 'task.status.update',
          [config.eventEntity.fields.status]: status,
          [config.eventEntity.fields.createdAt]: Math.floor(Date.now() / 1000)
        }

        if (entityId) {
          eventData[config.eventEntity.fields.entityId] = entityId
        }

        if (externalId) {
          eventData[config.eventEntity.fields.externalId] = externalId
        }

        if (data) {
          eventData[config.eventEntity.fields.data] = data
        }

        if (errorMessage) {
          eventData[config.eventEntity.fields.data] = {
            ...eventData[config.eventEntity.fields.data],
            errorMessage,
            errorCode: 'api_error'
          }
        }

        await controller.system.storage.create(config.eventEntity.entityName, eventData)

        console.log('[FangzhouVideoGeneration] Integration event created', {
          entityId,
          externalId,
          status,
          hasData: !!data,
          hasError: !!errorMessage
        })
      } catch (error: any) {
        console.error('[FangzhouVideoGeneration] Failed to create integration event', {
          entityId,
          externalId,
          status,
          error: error.message
        })
      }
    }
  }
}
