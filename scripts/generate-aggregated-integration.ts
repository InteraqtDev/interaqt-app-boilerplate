/**
 * Generate Aggregated Integration Script
 * 
 * Scans all *.entry.ts files in integrations/entries/ directory
 * and generates integrations/entries/index.ts that aggregates them all.
 * 
 * Usage: npx tsx scripts/generate-aggregated-integration.ts
 */

import * as fs from 'fs'
import * as path from 'path'

// Use process.cwd() to get project root
const projectRoot = process.cwd()

const ENTRIES_DIR = path.resolve(projectRoot, 'integrations/entries')
const OUTPUT_FILE = path.join(ENTRIES_DIR, 'index.ts')

interface EntryInfo {
  fileName: string
  importName: string
  variableName: string
  namespace: string
}

function getEntryFiles(): EntryInfo[] {
  const files = fs.readdirSync(ENTRIES_DIR)
  
  return files
    .filter(f => f.endsWith('.entry.ts'))
    .map(fileName => {
      // auth.entry.ts -> auth
      const baseName = fileName.replace('.entry.ts', '')
      // auth -> Auth, nanobanana2-image -> Nanobanana2Image
      const variableName = baseName
        .split('-')
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join('')
      // namespace 使用 baseName（小写形式），作为 API namespace 前缀
      const namespace = baseName.split('-').join('')
      
      return {
        fileName,
        importName: `./${fileName.replace('.ts', '.js')}`,
        variableName: `${variableName}Integration`,
        namespace
      }
    })
    .sort((a, b) => a.fileName.localeCompare(b.fileName))
}

function generateIndexContent(entries: EntryInfo[]): string {
  if (entries.length === 0) {
    return `// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by scripts/generate-aggregated-integration.ts
// Run: npx tsx scripts/generate-aggregated-integration.ts

import { createAggregatedIntegration } from "@/integrations/index"

// Aggregate all integration instances (currently empty)
const AggregatedIntegrationClass = createAggregatedIntegration({})

export default AggregatedIntegrationClass
`
  }

  const imports = entries
    .map(e => `import ${e.variableName} from '${e.importName}'`)
    .join('\n')
  
  // 生成 kv 结构，key 是 namespace
  const integrationKVList = entries
    .map(e => `  '${e.namespace}': ${e.variableName}`)
    .join(',\n')
  
  return `// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by scripts/generate-aggregated-integration.ts
// Run: npx tsx scripts/generate-aggregated-integration.ts

import { createAggregatedIntegration } from "@/integrations/index"
${imports}

// Aggregate all integration instances
// Key is namespace, value is integration class
const AggregatedIntegrationClass = createAggregatedIntegration({
${integrationKVList}
})

export default AggregatedIntegrationClass
`
}

function main() {
  console.log('[generate-aggregated-integration] Scanning entries directory...')
  
  // Ensure entries directory exists
  if (!fs.existsSync(ENTRIES_DIR)) {
    fs.mkdirSync(ENTRIES_DIR, { recursive: true })
  }
  
  const entries = getEntryFiles()
  
  if (entries.length === 0) {
    console.log('[generate-aggregated-integration] No entry files found, generating empty aggregation')
  } else {
    console.log(`[generate-aggregated-integration] Found ${entries.length} entry files:`)
    entries.forEach(e => console.log(`  - ${e.fileName} -> ${e.variableName}`))
  }
  
  const content = generateIndexContent(entries)
  
  fs.writeFileSync(OUTPUT_FILE, content, 'utf-8')
  
  console.log(`[generate-aggregated-integration] Generated ${OUTPUT_FILE}`)
}

main()

