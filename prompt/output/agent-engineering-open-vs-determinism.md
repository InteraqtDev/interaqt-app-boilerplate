# 在 Agent 工程里同时追求「开放」与「确定」

最近读到两份材料：

- Claude 文档： [Programmatic tool calling](https://platform.claude.com/docs/en/agents-and-tools/tool-use/programmatic-tool-calling)
- Refly 项目：`https://github.com/refly-ai/refly`

它们让我从两个角度看到同一件事：**在 agent 的执行过程中寻找更多“可控的确定性”，以提高成功率，同时保持系统的“策略开放性”，让模型能力提升时系统能自动受益。**

下面把“原材料要点 / 我的观点 / 补充框架”整理成一篇简单易读的笔记。

---

## 1. 两份原材料分别在解决什么问题

### 1.1 Programmatic tool calling：把“会影响世界的动作”变得可控

这类文档的核心不在“让模型更聪明”，而在于把模型的输出**落到可验证、可约束的接口**上：

- **工具接口是契约**：用结构化输入（schema）描述工具参数，减少歧义。
- **执行由系统负责**：模型提出调用建议，系统按确定规则执行、返回结果。
- **可观测与可恢复**：工具返回的错误、结果都能被记录、复用、重试、回放。

一句话：**LLM 做“决策”，系统做“执行”，并用契约把执行固定住。**

### 1.2 Refly：把 agent 组织成可演进的工作流/图

以 Refly 这类项目为代表，更强调“如何组织能力”而不是“单次推理有多强”：

- **把任务拆成节点/步骤**，让每步有清晰输入输出。
- **在多个能力之间编排**（检索、规划、写作、工具调用、记忆等）。
- **更容易替换/增强模块**：模型、检索、工具、规则都能演进。

一句话：**把 agent 从“单次对话”提升到“可组合系统”，并让系统可持续变强。**

---

## 2. 共同主线：开放性 + 确定性

你在 `prompt/discuss.md` 里提出的判断我认为是对的：

- **开放性**：相比写死固定 workflow，由 agent（LLM）做整体调度，让系统在模型变强时自然升级。
- **确定性**：相比纯 prompt，把执行计划交给代码或 DSL（工作流引擎）来执行，用结构和约束降低不确定性。

我会把它再“工程化”一点：

> 不追求让 LLM 本身变得确定，而是让 LLM 的输出进入一条**可约束、可验证、可回放**的轨道。

这能解释为什么这两份材料看起来风格不同，但目标一致：都是在把“不可控的语言生成”转成“可控的系统行为”。

---

## 3. 一个更清晰的分层模型：哪里开放？哪里确定？

把一个 agent 系统拆成三层，会更容易设计：

1) **语义决策层（开放）**
- 负责：任务分解、路径选择、工具选择、异常应对策略。
- 价值：模型越强，这层越强，系统自然收益。

2) **执行与证据层（确定）**
- 负责：真正产生副作用的动作（写数据库、调用外部服务、改代码、发请求）。
- 手段：schema/类型、权限控制、幂等、超时与重试策略、日志与审计。
- 目标：同样输入得到同样执行轨迹；错误可诊断。

3) **改良闭环层（持续变强）**
- 负责：评测、回归、线上观测、失败分析、把经验固化到规则/测试里。
- 目标：不是“这次做对”，而是“下次更容易做对”。

你原本的“开放 vs 确定”主要覆盖了 1) 与 2)。我认为 3) 是工程里经常被低估、但决定系统上限的部分。

---

## 4. 我补充的 3 个关键工程要素（比“DSL”更关键）

### 4.1 契约（Contract）比 DSL 本身更重要

DSL/工作流只是载体，真正带来确定性的通常是：

- **输入输出可校验**（schema、类型、约束条件）
- **失败模式可枚举**（错误码、可重试/不可重试、降级策略）

否则 DSL 也可能变成“另一种 prompt”。

### 4.2 验证（Verification）要尽量前置、尽量细粒度

把“做错了才发现”变成“准备做就能发现”：

- **前置校验**：权限、参数约束、资源存在性。
- **dry-run / plan**：先生成计划，再执行。
- **断言式检查**：每步有 pre/post conditions。

### 4.3 回放与归因（Replay & Attribution）是确定性的终极形态

系统可控的标志不是“看起来挺稳”，而是：

- **可回放**：相同输入、相同工具版本、相同数据快照 → 可复现执行轨迹。
- **可归因**：失败能定位是“模型判断”还是“工具/数据/环境变化”。

---

## 5. 落地清单：如何同时得到开放与确定

如果把上面抽象落到工程实践，通常是一套组合拳：

- **工具与副作用隔离**：把副作用放在工具层，模型只产生意图与参数。
- **结构化调用**：schema/类型约束 + 统一返回结构（含错误分类）。
- **权限与约束**：能做什么、不能做什么，在执行层硬限制。
- **可观测**：步骤日志、输入输出快照、工具耗时与失败率。
- **评测与回归**：固定一组“golden tasks”，每次改 agent/提示/流程都跑回归。
- **失败沉淀**：把一次失败转成规则、测试、或更严格的契约，而不是只改 prompt。

---

## 6. 一个更可复用的结论（可替换你原文的总结段）

**用 LLM 保持系统的策略开放性，用严格的工具契约与可验证执行把不确定性压缩到可控边界内，并通过可回放与评测闭环持续提高成功率。**

---

## 附：材料链接

- Claude programmatic tool calling： [Agents and tools: Programmatic tool calling](https://platform.claude.com/docs/en/agents-and-tools/tool-use/programmatic-tool-calling)
- Refly：`https://github.com/refly-ai/refly`
