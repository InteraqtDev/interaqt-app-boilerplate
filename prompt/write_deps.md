# 问题背景

业务模块之间的 entity/relation 可能存在业务逻辑上的 "写依赖"。"写依赖"是指的后来的模块需要修改原来模块中的 entity/relation 的数据变化逻辑。
例如 积分模块中的 积分实体，可能会被后来的礼物模块"写依赖"，因为购买礼物需要消耗积分。同样的，随着业务发展，未来还可能有更多的模块中的逻辑需要消耗积分。
因为我们使用的框架 interaqt 是一个响应式的数据框架，在这个框架中的数据变化应该始终遵循响应式的原则。所以我们始终是在通过响应式的方式定义数据，当数据依赖发生变化时，数据自动根据规律变化。而不是主动去修改数据。

在这个范式下，要处理"写依赖"的逻辑是有一定的困难的。因为在这个范式下，我们不能在后续模块逻辑里主动去修改之前模块中的数据。但是如果每次有新的写依赖出现时，我们都去修改被依赖的实体/关系的响应式表达，那么就会使得模块之间强耦合，并且后续模块如果要卸载，也还得去改写依赖的响应式表达。
为了解决这个问题，我们应该使用框架提供的 merged entity/ merged relation 概念。我们会被其他模块"写依赖"的 entity/relation 的响应式表达(computation) 写成基于 merged entity/merged relation 的形式，后续的模块可以把影响逻辑的数据加入到这个 merged entity/merged relation 中，就能实现影响/修改原本逻辑的效果了。

例如积分模块中的积分，积分是充值记录和消费记录的综合计算结果。未来可能会有很多种消费记录，我们可以把消费记录表达成 merged entity，通过定义 merged entity 的 commonProperties 来定义它应该有的通用的属性。然后积分 entity 基于充值记录和 merged entity 表达的消费记录进行计算表达即可。后续模块中如果有新的项目需要扣积分，那么就也创建一个符合 commonProperties 定义的新的消费 entity，把它加入到 merged 消费记录 entity 的 inputEntities 中即可。

# 任务一
你深入理解上述问题和解法，进行精炼总结。并回答以下问题：
1. 如何在业务需求描述中识别出未来可能产生的"写依赖"，例如需求文档 `requirements/credit.requirements.md`，你能否识别出写依赖。
2. 识别出写依赖之后，你会根据什么原则/步骤来设计 merged entity/merged relation，以及对应的 commonProperties?
